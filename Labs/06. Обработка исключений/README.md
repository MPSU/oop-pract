# Лабораторная работа 6: Обработка исключений

## Теоретическая часть

Ошибки в программах можно разделить на два типа:
- **Ошибки времени компиляции** – возникают при компиляции программы, например, из-за синтаксических ошибок.
- **Ошибки времени выполнения** – возникают в процессе работы программы, например, при некорректном вводе данных пользователем.

Одним из способов обработки ошибок времени выполнения являются **исключения**. Исключения позволяют избежать аварийного завершения программы, передавая управление специальным обработчикам ошибок.

### `try` и `catch`

Для перехвата и обработки исключений применяется конструкция `try` - `catch`. Блок кода, в котором может возникнуть ошибка, заключается в `try`. Если внутри него возникает исключение, выполнение передается в соответствующий `catch`-блок.

Пример:
```cpp
#include <iostream>
#include <string>

int main() {
    std::string str;
    std::cin >> str;

    try {
        int year = std::stoi(str);
        std::cout << "Введенный год: " << year << std::endl;
    }
    catch (const std::invalid_argument& ex) {
        std::cout << "Недопустимое число: " << ex.what() << std::endl;
    }
    catch (const std::out_of_range& ex) {
        std::cout << "Число выходит за пределы допустимого диапазона: " << ex.what() << std::endl;
    }
    
    return 0;
}
```

В этом примере, если пользователь введет некорректное число, `std::stoi` выбросит исключение, и выполнение перейдет в `catch`-блок.

### `throw`

Для генерации исключений используется оператор `throw`. Можно выбрасывать исключения различных типов:
```cpp
throw 5;                                        // Целочисленное исключение
throw std::string("Ошибка!");                   // Исключение строкового типа
throw std::runtime_error("Ошибка выполнения!"); // Исключение runtime
```

Пример с проверкой корректности введенного года:
```cpp
int year;
std::cin >> year;
if (year < 1905 || year > 2030) {
    throw std::invalid_argument("Введен неправильный год");
}
```

### Обработка нескольких типов исключений
Можно перехватывать разные типы исключений, используя несколько `catch`-блоков:
```cpp
try {
    throw std::runtime_error("Что-то пошло не так");
}
catch (const std::invalid_argument& ex) {
    std::cout << "Ошибка аргумента: " << ex.what() << std::endl;
}
catch (const std::exception& ex) {
    std::cout << "Общая ошибка: " << ex.what() << std::endl;
}
catch (...) {
    std::cout << "Неизвестная ошибка" << std::endl;
}
```
Последний `catch (...)` перехватывает любые исключения, если их тип не был явно указан в предыдущих блоках.

### Раскручивание стека

Если исключение, выработанное в текущей исполняемой функции, не было перехвачено в этой функции (`catch` отсутствует или не соответствует типу исключения), программа начинает так называвемое **раскручивание стека**: 
- Выполнение выходит из текущей функции и переходит к вызывающей.
- Если в вызывающей функции тоже нет подходящего `catch`, выход продолжается по стеку вызовов.
- Если в конечном итоге исключение не будет обработано, программа аварийно завершится, часто с сообщением о необработанном исключении.

Пример:
```cpp
void foo() {
    throw std::runtime_error("Ошибка в foo");
}

void bar() {
    foo(); // Исключение не обрабатывается здесь
}

int main() {
    bar(); // Исключение "поднимается" сюда и завершает программу
    return 0;
}
```
В этом коде исключение поднимается по стеку от `foo()` → `bar()` → `main()`, так как нигде не было `catch`, и программа аварийно завершается.

## Практическое задание

1) **Модифицировать CsvReader**:
   - Завернуть вызовы `std::stoi` в `try` - `catch`, чтобы при ошибках в CSV-файле программа не падала, а выводила сообщение и продолжала работать.
   
2) **Создать собственный класс исключения**:
   - Разработать класс `CsvParseException`, наследованный от `std::exception`.
   - Исключение должно хранить текстовое описание ошибки и номер строки, где она произошла.
   - Использовать `throw CsvParseException` в `CsvReader` при ошибках в `std::stoi`.

Пример реализации класса исключения:
```cpp
#include <exception>
#include <string>

class CsvParseException : public std::exception {
private:
    std::string message_;
    unsigned line_number_;

public:
    CsvParseException(const std::string& msg, unsigned line)
        : message_(msg), line_number_(line) {}

    const char* what() const noexcept override;

    unsigned lineNumber() const;
};
```

3) **Добавить обработку исключений в `MainWindow`**:
   - Перехватывать `CsvParseException` при вызове `CsvReader::readAll()`.
   - Выводить сообщение об ошибке и номер строки в `textBrowser` красным цветом.

Пример обработки в `MainWindow`:
```cpp
try {
    csvReader.readAll();
}
catch (const CsvParseException& ex) {
    textBrowser->append("Ошибка в строке " + QString::number(ex.lineNumber()) + ": " + ex.what());
}
```
