# Лабораторная работа 4: Наследование

## Теоретическая часть

### Основы наследования в C++

Наследование позволяет создавать новые классы (`производные` или `дочерние`), которые расширяют или модифицируют функциональность существующих (`базовых`) классов. В C++ наследование осуществляется с помощью следующего синтаксиса:
```cpp
class Base {
public:
    void baseFunction() {
        std::cout << "Base function" << std::endl;
    }
};

class Derived : public Base {
public:
    void derivedFunction() {
        std::cout << "Derived function" << std::endl;
    }
};
```
Использование:
```cpp
Derived obj;
obj.baseFunction();     // Можно вызвать метод базового класса
obj.derivedFunction();  // Можно вызвать метод производного класса
```
Если наследование открытое (`public`), то все `public` и `protected` члены базового класса остаются доступными в производном классе. Закрытое (`private`) наследование ограничивает доступ к членам базового класса.

### Полиморфизм и override в C++

Полиморфизм — это механизм ООП, который позволяет работать с разными типами объектов через единый интерфейс. В C++ это реализуется через виртуальные функции.

Пример базового и дочернего классов с переопределением метода:
```cpp
class Base {
public:
    virtual void show() const {
        std::cout << "Base class" << std::endl;
    }
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    void show() const override {
        std::cout << "Derived class" << std::endl;
    }
};
```
Использование:
```cpp
Base* obj = new Derived();
obj->show(); // Выведет "Derived class"
delete obj;
```
Ключевое слово `override` явно указывает, что метод переопределяет виртуальную функцию из базового класса.

### Наследование виджетов Qt

Наследование — это один из ключевых механизмов объектно-ориентированного программирования (ООП), который позволяет создавать новые классы на основе уже существующих, расширяя или изменяя их функциональность. В библиотеке Qt данный принцип используется для создания пользовательских виджетов, основанных на стандартных элементах управления.

Все элементы окна в Qt образуют иерархию, так что у каждого виджета есть родитель (*англ.* parent, не путать с родителем при наследовании в ООП) — виджет, на котором он расположен. Благодаря этому, управление ресурсами и отображением элементов интерфейса упрощается. 

При создании пользовательского виджета необходимо явно передавать указатель на родительский элемент в конструкторе:
```cpp
MyWidget(QWidget* parent = nullptr);
```
Передача `parent` в конструктор базового класса выполняется через список инициализации, например:
```cpp
MyWidget::MyWidget(QWidget* parent) : QWidget(parent) {}
```

### Создание пользовательских виджетов в QtCreator

Для создания собственного виджета в QtCreator:
1. Создайте новый класс C++ и укажите базовый класс (например, `QWidget`).
2. Подключите заголовочный файл `QWidget` и добавьте макрос `Q_OBJECT` в объявление класса.
3. Определите конструктор с указателем на родительский объект.
4. Реализуйте дополнительную функциональность нового виджета.

Пример реализации пользовательского виджета `MyWidget`:
```cpp
// MyWidget.h
#ifndef MYWIDGET_H
#define MYWIDGET_H

#include <QWidget>
#include <QPushButton>

class MyWidget : public QWidget {
    Q_OBJECT
public:
    explicit MyWidget(QWidget* parent = nullptr);

private:
    QPushButton* button;
};

#endif // MYWIDGET_H
```

```cpp
// MyWidget.cpp
#include "MyWidget.h"
#include <QVBoxLayout>

MyWidget::MyWidget(QWidget* parent) : QWidget(parent) {
    button = new QPushButton("Click me", this);
    QVBoxLayout* layout = new QVBoxLayout(this);
    layout->addWidget(button);
    setLayout(layout);
}
```

Чтобы использовать пользовательский виджет в дизайнере интерфейса:
1. Добавьте стандартный родительский виджет в окно.
2. Щелкните по нему правой кнопкой мыши и выберите `Преобразовать в ...`.
3. Укажите имя нового класса и заголовочный файл.
4. Нажмите `Добавить`, затем `Преобразовать`.
5. В результате в иерархии элементов вашего окна родительский класс будет заменен на новый дочерний.

См. [Using Custom Widgets with Qt Widgets Designer](https://doc.qt.io/qt-6/designer-using-custom-widgets.html)

После этого к пользовательскому виджету можно обращаться через `ui->widgetName->...`.

### Подключение заголовочного файла в CMake

При возникновении ошибок компиляции, связанных с отсутствием заголовочного файла пользовательского класса, добавьте в `CMakeLists.txt` строку:
```cmake
target_include_directories(proj PUBLIC ${CMAKE_CURRENT_LIST_DIR})
```
где `proj` — имя *ВАШЕГО* проекта (указано в директиве `project(...)`).

---

## Практическая часть

### Задания

1) **Переделать класс из ЛР1:**
   - добавить значения по умолчанию для всех атрибутов;
   - убрать тело конструктора по умолчанию и сделать его `= default`;
   - специальный конструктор реализовать через список инициализации.

2) **Создать дочерний класс от базового класса из ЛР1:**
   - добавить новые атрибуты, например:
     - `Книга` → `Журнал` (периодичность);
     - `Кино` → `Сериал` (количество сезонов);
   - создать сеттеры и геттеры для новых свойств;
   - создать специальный конструктор с передачей значений через список инициализации;
   - реализуйте полиморфное поведение, переопределив виртуальные методы в дочернем классе;
   - используйте ключевое слово `override` для явного указания переопределённых методов.

3) **Переделать `CsvReader` и `CsvWriter` для работы с новым дочерним классом.**

4) **Создать класс `MyTextBrowser`, наследованный от `QTextBrowser`:**
   - добавить функцию `appendBook` (или аналогичную), которая будет выводить объекты пользовательского класса;
   - организовать весь вывод данных через эту функцию.
